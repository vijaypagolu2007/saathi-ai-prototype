"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(app)/moods/page",{

/***/ "(app-pages-browser)/./src/lib/firestore.ts":
/*!******************************!*\
  !*** ./src/lib/firestore.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addJournalEntry: () => (/* binding */ addJournalEntry),\n/* harmony export */   addMoodEntry: () => (/* binding */ addMoodEntry),\n/* harmony export */   getJournalEntries: () => (/* binding */ getJournalEntries),\n/* harmony export */   getMoodEntries: () => (/* binding */ getMoodEntries)\n/* harmony export */ });\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n\n\n// Add a new journal entry for a specific user\nconst addJournalEntry = async (userId, entryData)=>{\n    try {\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId, 'journal'), {\n            ...entryData,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)(),\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n        });\n    } catch (error) {\n        console.error(\"Error adding journal entry: \", error);\n        throw new Error('Failed to add journal entry.');\n    }\n};\n// Get all journal entries for a specific user\nconst getJournalEntries = async (userId)=>{\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId, 'journal'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)('createdAt', 'desc'));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const entries = [];\n        querySnapshot.forEach((doc)=>{\n            var _data_createdAt, _data_updatedAt;\n            const data = doc.data();\n            var _data_createdAt_toDate;\n            const createdAt = (_data_createdAt_toDate = (_data_createdAt = data.createdAt) === null || _data_createdAt === void 0 ? void 0 : _data_createdAt.toDate()) !== null && _data_createdAt_toDate !== void 0 ? _data_createdAt_toDate : new Date();\n            var _data_updatedAt_toDate;\n            const updatedAt = (_data_updatedAt_toDate = (_data_updatedAt = data.updatedAt) === null || _data_updatedAt === void 0 ? void 0 : _data_updatedAt.toDate()) !== null && _data_updatedAt_toDate !== void 0 ? _data_updatedAt_toDate : new Date();\n            entries.push({\n                id: doc.id,\n                userId: userId,\n                date: createdAt.toISOString(),\n                createdAt: createdAt.toISOString(),\n                updatedAt: updatedAt.toISOString(),\n                title: data.title || 'Untitled Entry',\n                prompt: data.prompt,\n                content: data.content,\n                summary: data.summary,\n                analysis: data.analysis\n            });\n        });\n        return entries;\n    } catch (error) {\n        console.error(\"Error getting journal entries: \", error);\n        throw new Error('Failed to get journal entries.');\n    }\n};\n// Add a new mood entry for a specific user\nconst addMoodEntry = async (userId, moodData)=>{\n    try {\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId, 'moods'), {\n            ...moodData,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.serverTimestamp)()\n        });\n    } catch (error) {\n        console.error(\"Error adding mood entry: \", error);\n        throw new Error('Failed to add mood entry.');\n    }\n};\n// Get all mood entries for a specific user\nconst getMoodEntries = async (userId)=>{\n    try {\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_0__.db, 'users', userId, 'moods'), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.orderBy)('createdAt', 'desc'));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_1__.getDocs)(q);\n        const entries = [];\n        querySnapshot.forEach((doc)=>{\n            var _data_createdAt;\n            const data = doc.data();\n            var _data_createdAt_toDate;\n            const createdAt = (_data_createdAt_toDate = (_data_createdAt = data.createdAt) === null || _data_createdAt === void 0 ? void 0 : _data_createdAt.toDate()) !== null && _data_createdAt_toDate !== void 0 ? _data_createdAt_toDate : new Date();\n            entries.push({\n                id: doc.id,\n                userId: userId,\n                date: createdAt.toISOString(),\n                createdAt: createdAt.toISOString(),\n                mood: data.mood,\n                moodScore: data.moodScore\n            });\n        });\n        return entries;\n    } catch (error) {\n        console.error(\"Error getting mood entries: \", error);\n        throw new Error('Failed to get mood entries.');\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmlyZXN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNnQztBQUNrRTtBQUdsRyw4Q0FBOEM7QUFDdkMsTUFBTU8sa0JBQWtCLE9BQU9DLFFBQWdCQztJQUNwRCxJQUFJO1FBQ0YsTUFBTVAsMERBQU1BLENBQUNELDhEQUFVQSxDQUFDRCx5Q0FBRUEsRUFBRSxTQUFTUSxRQUFRLFlBQVk7WUFDdkQsR0FBR0MsU0FBUztZQUNaQyxXQUFXSixtRUFBZUE7WUFDMUJLLFdBQVdMLG1FQUFlQTtRQUM1QjtJQUNGLEVBQUUsT0FBT00sT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtRQUM5QyxNQUFNLElBQUlFLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRUYsOENBQThDO0FBQ3ZDLE1BQU1DLG9CQUFvQixPQUFPUDtJQUN0QyxJQUFJO1FBQ0YsTUFBTVEsSUFBSVoseURBQUtBLENBQUNILDhEQUFVQSxDQUFDRCx5Q0FBRUEsRUFBRSxTQUFTUSxRQUFRLFlBQVlILDJEQUFPQSxDQUFDLGFBQWE7UUFDakYsTUFBTVksZ0JBQWdCLE1BQU1kLDJEQUFPQSxDQUFDYTtRQUNwQyxNQUFNRSxVQUEwQixFQUFFO1FBQ2xDRCxjQUFjRSxPQUFPLENBQUMsQ0FBQ0M7Z0JBRUhDLGlCQUNBQTtZQUZsQixNQUFNQSxPQUFPRCxJQUFJQyxJQUFJO2dCQUNIQTtZQUFsQixNQUFNWCxZQUFZVyxDQUFBQSwwQkFBQUEsa0JBQUFBLEtBQUtYLFNBQVMsY0FBZFcsc0NBQUFBLGdCQUFnQkMsTUFBTSxnQkFBdEJELG9DQUFBQSx5QkFBNEIsSUFBSUU7Z0JBQ2hDRjtZQUFsQixNQUFNVixZQUFZVSxDQUFBQSwwQkFBQUEsa0JBQUFBLEtBQUtWLFNBQVMsY0FBZFUsc0NBQUFBLGdCQUFnQkMsTUFBTSxnQkFBdEJELG9DQUFBQSx5QkFBNEIsSUFBSUU7WUFFbERMLFFBQVFNLElBQUksQ0FBQztnQkFDWEMsSUFBSUwsSUFBSUssRUFBRTtnQkFDVmpCLFFBQVFBO2dCQUNSa0IsTUFBTWhCLFVBQVVpQixXQUFXO2dCQUMzQmpCLFdBQVdBLFVBQVVpQixXQUFXO2dCQUNoQ2hCLFdBQVdBLFVBQVVnQixXQUFXO2dCQUNoQ0MsT0FBT1AsS0FBS08sS0FBSyxJQUFJO2dCQUNyQkMsUUFBUVIsS0FBS1EsTUFBTTtnQkFDbkJDLFNBQVNULEtBQUtTLE9BQU87Z0JBQ3JCQyxTQUFTVixLQUFLVSxPQUFPO2dCQUNyQkMsVUFBVVgsS0FBS1csUUFBUTtZQUN6QjtRQUNGO1FBQ0EsT0FBT2Q7SUFDVCxFQUFFLE9BQU9OLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG1DQUFtQ0E7UUFDakQsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0FBQ0YsRUFBRTtBQUVGLDJDQUEyQztBQUNwQyxNQUFNbUIsZUFBZSxPQUFPekIsUUFBZ0IwQjtJQUMvQyxJQUFJO1FBQ0EsTUFBTWhDLDBEQUFNQSxDQUFDRCw4REFBVUEsQ0FBQ0QseUNBQUVBLEVBQUUsU0FBU1EsUUFBUSxVQUFVO1lBQ25ELEdBQUcwQixRQUFRO1lBQ1h4QixXQUFXSixtRUFBZUE7UUFDOUI7SUFDSixFQUFFLE9BQU9NLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsTUFBTSxJQUFJRSxNQUFNO0lBQ3BCO0FBQ0osRUFBRTtBQUVGLDJDQUEyQztBQUNwQyxNQUFNcUIsaUJBQWlCLE9BQU8zQjtJQUNqQyxJQUFJO1FBQ0EsTUFBTVEsSUFBSVoseURBQUtBLENBQUNILDhEQUFVQSxDQUFDRCx5Q0FBRUEsRUFBRSxTQUFTUSxRQUFRLFVBQVVILDJEQUFPQSxDQUFDLGFBQWE7UUFDL0UsTUFBTVksZ0JBQWdCLE1BQU1kLDJEQUFPQSxDQUFDYTtRQUNwQyxNQUFNRSxVQUF1QixFQUFFO1FBQy9CRCxjQUFjRSxPQUFPLENBQUMsQ0FBQ0M7Z0JBRURDO1lBRGxCLE1BQU1BLE9BQU9ELElBQUlDLElBQUk7Z0JBQ0hBO1lBQWxCLE1BQU1YLFlBQVlXLENBQUFBLDBCQUFBQSxrQkFBQUEsS0FBS1gsU0FBUyxjQUFkVyxzQ0FBQUEsZ0JBQWdCQyxNQUFNLGdCQUF0QkQsb0NBQUFBLHlCQUE0QixJQUFJRTtZQUVsREwsUUFBUU0sSUFBSSxDQUFDO2dCQUNUQyxJQUFJTCxJQUFJSyxFQUFFO2dCQUNWakIsUUFBUUE7Z0JBQ1JrQixNQUFNaEIsVUFBVWlCLFdBQVc7Z0JBQzNCakIsV0FBV0EsVUFBVWlCLFdBQVc7Z0JBQ2hDUyxNQUFNZixLQUFLZSxJQUFJO2dCQUNmQyxXQUFXaEIsS0FBS2dCLFNBQVM7WUFDN0I7UUFDSjtRQUNBLE9BQU9uQjtJQUNYLEVBQUUsT0FBT04sT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsZ0NBQWdDQTtRQUM5QyxNQUFNLElBQUlFLE1BQU07SUFDcEI7QUFDSixFQUFFIiwic291cmNlcyI6WyIvaG9tZS91c2VyL3N0dWRpby9zcmMvbGliL2ZpcmVzdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IGRiIH0gZnJvbSAnLi9maXJlYmFzZSc7XG5pbXBvcnQgeyBjb2xsZWN0aW9uLCBhZGREb2MsIGdldERvY3MsIHF1ZXJ5LCBvcmRlckJ5LCBzZXJ2ZXJUaW1lc3RhbXAgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHR5cGUgeyBKb3VybmFsRW50cnksIE1vb2RFbnRyeSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBBZGQgYSBuZXcgam91cm5hbCBlbnRyeSBmb3IgYSBzcGVjaWZpYyB1c2VyXG5leHBvcnQgY29uc3QgYWRkSm91cm5hbEVudHJ5ID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nLCBlbnRyeURhdGE6IE9taXQ8Sm91cm5hbEVudHJ5LCAnaWQnIHwgJ3VzZXJJZCcgfCAnZGF0ZScgfCAnY3JlYXRlZEF0JyB8ICd1cGRhdGVkQXQnPikgPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCAndXNlcnMnLCB1c2VySWQsICdqb3VybmFsJyksIHtcbiAgICAgIC4uLmVudHJ5RGF0YSxcbiAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhZGRpbmcgam91cm5hbCBlbnRyeTogXCIsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhZGQgam91cm5hbCBlbnRyeS4nKTtcbiAgfVxufTtcblxuLy8gR2V0IGFsbCBqb3VybmFsIGVudHJpZXMgZm9yIGEgc3BlY2lmaWMgdXNlclxuZXhwb3J0IGNvbnN0IGdldEpvdXJuYWxFbnRyaWVzID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxKb3VybmFsRW50cnlbXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHEgPSBxdWVyeShjb2xsZWN0aW9uKGRiLCAndXNlcnMnLCB1c2VySWQsICdqb3VybmFsJyksIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJykpO1xuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIGNvbnN0IGVudHJpZXM6IEpvdXJuYWxFbnRyeVtdID0gW107XG4gICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgY29uc3QgY3JlYXRlZEF0ID0gZGF0YS5jcmVhdGVkQXQ/LnRvRGF0ZSgpID8/IG5ldyBEYXRlKCk7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSBkYXRhLnVwZGF0ZWRBdD8udG9EYXRlKCkgPz8gbmV3IERhdGUoKTtcbiAgICAgIFxuICAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgdXNlcklkOiB1c2VySWQsXG4gICAgICAgIGRhdGU6IGNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICAgICAgICBjcmVhdGVkQXQ6IGNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkQXQ6IHVwZGF0ZWRBdC50b0lTT1N0cmluZygpLFxuICAgICAgICB0aXRsZTogZGF0YS50aXRsZSB8fCAnVW50aXRsZWQgRW50cnknLFxuICAgICAgICBwcm9tcHQ6IGRhdGEucHJvbXB0LFxuICAgICAgICBjb250ZW50OiBkYXRhLmNvbnRlbnQsXG4gICAgICAgIHN1bW1hcnk6IGRhdGEuc3VtbWFyeSxcbiAgICAgICAgYW5hbHlzaXM6IGRhdGEuYW5hbHlzaXMsXG4gICAgICB9IGFzIEpvdXJuYWxFbnRyeSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgam91cm5hbCBlbnRyaWVzOiBcIiwgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBqb3VybmFsIGVudHJpZXMuJyk7XG4gIH1cbn07XG5cbi8vIEFkZCBhIG5ldyBtb29kIGVudHJ5IGZvciBhIHNwZWNpZmljIHVzZXJcbmV4cG9ydCBjb25zdCBhZGRNb29kRW50cnkgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIG1vb2REYXRhOiBPbWl0PE1vb2RFbnRyeSwgJ2lkJyB8ICd1c2VySWQnIHwgJ2RhdGUnIHwgJ2NyZWF0ZWRBdCc+KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICd1c2VycycsIHVzZXJJZCwgJ21vb2RzJyksIHtcbiAgICAgICAgICAgIC4uLm1vb2REYXRhLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyBtb29kIGVudHJ5OiBcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBhZGQgbW9vZCBlbnRyeS4nKTtcbiAgICB9XG59O1xuXG4vLyBHZXQgYWxsIG1vb2QgZW50cmllcyBmb3IgYSBzcGVjaWZpYyB1c2VyXG5leHBvcnQgY29uc3QgZ2V0TW9vZEVudHJpZXMgPSBhc3luYyAodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPE1vb2RFbnRyeVtdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcSA9IHF1ZXJ5KGNvbGxlY3Rpb24oZGIsICd1c2VycycsIHVzZXJJZCwgJ21vb2RzJyksIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJykpO1xuICAgICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgICAgY29uc3QgZW50cmllczogTW9vZEVudHJ5W10gPSBbXTtcbiAgICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBkb2MuZGF0YSgpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gZGF0YS5jcmVhdGVkQXQ/LnRvRGF0ZSgpID8/IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICBkYXRlOiBjcmVhdGVkQXQudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IGNyZWF0ZWRBdC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1vb2Q6IGRhdGEubW9vZCxcbiAgICAgICAgICAgICAgICBtb29kU2NvcmU6IGRhdGEubW9vZFNjb3JlLFxuICAgICAgICAgICAgfSBhcyBNb29kRW50cnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgbW9vZCBlbnRyaWVzOiBcIiwgZXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgbW9vZCBlbnRyaWVzLicpO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOlsiZGIiLCJjb2xsZWN0aW9uIiwiYWRkRG9jIiwiZ2V0RG9jcyIsInF1ZXJ5Iiwib3JkZXJCeSIsInNlcnZlclRpbWVzdGFtcCIsImFkZEpvdXJuYWxFbnRyeSIsInVzZXJJZCIsImVudHJ5RGF0YSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwiZ2V0Sm91cm5hbEVudHJpZXMiLCJxIiwicXVlcnlTbmFwc2hvdCIsImVudHJpZXMiLCJmb3JFYWNoIiwiZG9jIiwiZGF0YSIsInRvRGF0ZSIsIkRhdGUiLCJwdXNoIiwiaWQiLCJkYXRlIiwidG9JU09TdHJpbmciLCJ0aXRsZSIsInByb21wdCIsImNvbnRlbnQiLCJzdW1tYXJ5IiwiYW5hbHlzaXMiLCJhZGRNb29kRW50cnkiLCJtb29kRGF0YSIsImdldE1vb2RFbnRyaWVzIiwibW9vZCIsIm1vb2RTY29yZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/firestore.ts\n"));

/***/ })

});