"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-uri";
exports.ids = ["vendor-chunks/fast-uri"];
exports.modules = {

/***/ "(action-browser)/./node_modules/fast-uri/index.js":
/*!****************************************!*\
  !*** ./node_modules/fast-uri/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = __webpack_require__(/*! ./lib/utils */ \"(action-browser)/./node_modules/fast-uri/lib/utils.js\")\nconst { SCHEMES, getSchemeHandler } = __webpack_require__(/*! ./lib/schemes */ \"(action-browser)/./node_modules/fast-uri/lib/schemes.js\")\n\n/**\n * @template {import('./types/index').URIComponent|string} T\n * @param {T} uri\n * @param {import('./types/index').Options} [options]\n * @returns {T}\n */\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = /** @type {T} */ (serialize(parse(uri, options), options))\n  } else if (typeof uri === 'object') {\n    uri = /** @type {T} */ (parse(serialize(uri, options), options))\n  }\n  return uri\n}\n\n/**\n * @param {string} baseURI\n * @param {string} relativeURI\n * @param {import('./types/index').Options} [options]\n * @returns {string}\n */\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = options ? Object.assign({ scheme: 'null' }, options) : { scheme: 'null' }\n  const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  schemelessOptions.skipEscape = true\n  return serialize(resolved, schemelessOptions)\n}\n\n/**\n * @param {import ('./types/index').URIComponent} base\n * @param {import ('./types/index').URIComponent} relative\n * @param {import('./types/index').Options} [options]\n * @param {boolean} [skipNormalization=false]\n * @returns {import ('./types/index').URIComponent}\n */\nfunction resolveComponent (base, relative, options, skipNormalization) {\n  /** @type {import('./types/index').URIComponent} */\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base component\n    relative = parse(serialize(relative, options), options) // normalize relative component\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path[0] === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\n/**\n * @param {import ('./types/index').URIComponent|string} uriA\n * @param {import ('./types/index').URIComponent|string} uriB\n * @param {import ('./types/index').Options} options\n * @returns {boolean}\n */\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\n/**\n * @param {Readonly<import('./types/index').URIComponent>} cmpts\n * @param {import('./types/index').Options} [opts]\n * @returns {string}\n */\nfunction serialize (cmpts, opts) {\n  const component = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = getSchemeHandler(options.scheme || component.scheme)\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options)\n\n  if (component.path !== undefined) {\n    if (!options.skipEscape) {\n      component.path = escape(component.path)\n\n      if (component.scheme !== undefined) {\n        component.path = component.path.split('%3A').join(':')\n      }\n    } else {\n      component.path = unescape(component.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && component.scheme) {\n    uriTokens.push(component.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(component)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (component.path && component.path[0] !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (component.path !== undefined) {\n    let s = component.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (\n      authority === undefined &&\n      s[0] === '/' &&\n      s[1] === '/'\n    ) {\n      // don't allow the path to start with \"//\"\n      s = '/%2F' + s.slice(2)\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (component.query !== undefined) {\n    uriTokens.push('?', component.query)\n  }\n\n  if (component.fragment !== undefined) {\n    uriTokens.push('#', component.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\n/**\n * @param {string} uri\n * @param {import('./types/index').Options} [opts]\n * @returns\n */\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  /** @type {import('./types/index').URIComponent} */\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n\n  let isIP = false\n  if (options.reference === 'suffix') {\n    if (options.scheme) {\n      uri = options.scheme + ':' + uri\n    } else {\n      uri = '//' + uri\n    }\n  }\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = isIPv4(parsed.host)\n      if (ipv4result === false) {\n        const ipv6result = normalizeIPv6(parsed.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme)\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (uri.indexOf('%') !== -1) {\n        if (parsed.scheme !== undefined) {\n          parsed.scheme = unescape(parsed.scheme)\n        }\n        if (parsed.host !== undefined) {\n          parsed.host = unescape(parsed.host)\n        }\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponent,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports[\"default\"] = fastUri\nmodule.exports.fastUri = fastUri\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLDRHQUE0RyxFQUFFLG1CQUFPLENBQUMsMEVBQWE7QUFDM0ksUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLDhFQUFlOztBQUU3RDtBQUNBLGNBQWMsNkNBQTZDO0FBQzNELFdBQVcsR0FBRztBQUNkLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsR0FBRztBQUN4QixJQUFJO0FBQ0oscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0IsZUFBZTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELFdBQVcsdUNBQXVDO0FBQ2xELFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDhDQUE4QztBQUN6RCxXQUFXLDhDQUE4QztBQUN6RCxXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsOEJBQThCO0FBQzdHLElBQUk7QUFDSiwrREFBK0QsOEJBQThCO0FBQzdGOztBQUVBO0FBQ0E7QUFDQSwrRUFBK0UsOEJBQThCO0FBQzdHLElBQUk7QUFDSiwrREFBK0QsOEJBQThCO0FBQzdGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdEQUFnRDtBQUMzRCxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBc0I7QUFDdEIsc0JBQXNCIiwic291cmNlcyI6WyIvaG9tZS91c2VyL3N0dWRpby9ub2RlX21vZHVsZXMvZmFzdC11cmkvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbm9ybWFsaXplSVB2NiwgcmVtb3ZlRG90U2VnbWVudHMsIHJlY29tcG9zZUF1dGhvcml0eSwgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsIGlzSVB2NCwgbm9uU2ltcGxlRG9tYWluIH0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpXG5jb25zdCB7IFNDSEVNRVMsIGdldFNjaGVtZUhhbmRsZXIgfSA9IHJlcXVpcmUoJy4vbGliL3NjaGVtZXMnKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gVFxuICogQHBhcmFtIHtUfSB1cmlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplICh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpID0gLyoqIEB0eXBlIHtUfSAqLyAoc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpID0gLyoqIEB0eXBlIHtUfSAqLyAocGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpKVxuICB9XG4gIHJldHVybiB1cmlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSVxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJJXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZSAoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lbGVzc09wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpIDogeyBzY2hlbWU6ICdudWxsJyB9XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUNvbXBvbmVudChwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKVxuICBzY2hlbWVsZXNzT3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVkLCBzY2hlbWVsZXNzT3B0aW9ucylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGJhc2VcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gcmVsYXRpdmVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTm9ybWFsaXphdGlvbj1mYWxzZV1cbiAqIEByZXR1cm5zIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50IChiYXNlLCByZWxhdGl2ZSwgb3B0aW9ucywgc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9ICovXG4gIGNvbnN0IHRhcmdldCA9IHt9XG4gIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKSAvLyBub3JtYWxpemUgYmFzZSBjb21wb25lbnRcbiAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lXG4gICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICB9IGVsc2Uge1xuICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aFxuICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUucGF0aFswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoYmFzZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IGJhc2UucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9ICcvJyArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICB9XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvXG4gICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnRcbiAgICB9XG4gICAgdGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lXG4gIH1cblxuICB0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudFxuXG4gIHJldHVybiB0YXJnZXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSB1cmlBXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSB1cmlCXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZXF1YWwgKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmlBID09PSAnc3RyaW5nJykge1xuICAgIHVyaUEgPSB1bmVzY2FwZSh1cmlBKVxuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQSwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQSA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUEsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXJpQiA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlCID0gdW5lc2NhcGUodXJpQilcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUIgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlCLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICByZXR1cm4gdXJpQS50b0xvd2VyQ2FzZSgpID09PSB1cmlCLnRvTG93ZXJDYXNlKClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWRvbmx5PGltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudD59IGNtcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRzXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplIChjbXB0cywgb3B0cykge1xuICBjb25zdCBjb21wb25lbnQgPSB7XG4gICAgaG9zdDogY21wdHMuaG9zdCxcbiAgICBzY2hlbWU6IGNtcHRzLnNjaGVtZSxcbiAgICB1c2VyaW5mbzogY21wdHMudXNlcmluZm8sXG4gICAgcG9ydDogY21wdHMucG9ydCxcbiAgICBwYXRoOiBjbXB0cy5wYXRoLFxuICAgIHF1ZXJ5OiBjbXB0cy5xdWVyeSxcbiAgICBuaWQ6IGNtcHRzLm5pZCxcbiAgICBuc3M6IGNtcHRzLm5zcyxcbiAgICB1dWlkOiBjbXB0cy51dWlkLFxuICAgIGZyYWdtZW50OiBjbXB0cy5mcmFnbWVudCxcbiAgICByZWZlcmVuY2U6IGNtcHRzLnJlZmVyZW5jZSxcbiAgICByZXNvdXJjZU5hbWU6IGNtcHRzLnJlc291cmNlTmFtZSxcbiAgICBzZWN1cmU6IGNtcHRzLnNlY3VyZSxcbiAgICBlcnJvcjogJydcbiAgfVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudC5zY2hlbWUpXG5cbiAgLy8gcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50LCBvcHRpb25zKVxuXG4gIGlmIChjb21wb25lbnQucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFvcHRpb25zLnNraXBFc2NhcGUpIHtcbiAgICAgIGNvbXBvbmVudC5wYXRoID0gZXNjYXBlKGNvbXBvbmVudC5wYXRoKVxuXG4gICAgICBpZiAoY29tcG9uZW50LnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC5wYXRoID0gY29tcG9uZW50LnBhdGguc3BsaXQoJyUzQScpLmpvaW4oJzonKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQucGF0aCA9IHVuZXNjYXBlKGNvbXBvbmVudC5wYXRoKVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcgJiYgY29tcG9uZW50LnNjaGVtZSkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudC5zY2hlbWUsICc6JylcbiAgfVxuXG4gIGNvbnN0IGF1dGhvcml0eSA9IHJlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnQpXG4gIGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcpIHtcbiAgICAgIHVyaVRva2Vucy5wdXNoKCcvLycpXG4gICAgfVxuXG4gICAgdXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KVxuXG4gICAgaWYgKGNvbXBvbmVudC5wYXRoICYmIGNvbXBvbmVudC5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgIHVyaVRva2Vucy5wdXNoKCcvJylcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcyA9IGNvbXBvbmVudC5wYXRoXG5cbiAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRob3JpdHkgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgc1swXSA9PT0gJy8nICYmXG4gICAgICBzWzFdID09PSAnLydcbiAgICApIHtcbiAgICAgIC8vIGRvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgICBzID0gJy8lMkYnICsgcy5zbGljZSgyKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKHMpXG4gIH1cblxuICBpZiAoY29tcG9uZW50LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnPycsIGNvbXBvbmVudC5xdWVyeSlcbiAgfVxuXG4gIGlmIChjb21wb25lbnQuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCcjJywgY29tcG9uZW50LmZyYWdtZW50KVxuICB9XG4gIHJldHVybiB1cmlUb2tlbnMuam9pbignJylcbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW14jLzo/XSspOik/KD86XFwvXFwvKCg/OihbXiMvP0BdKilAKT8oXFxbW14jLz9cXF1dK1xcXXxbXiMvOj9dKikoPzo6KFxcZCopKT8pKT8oW14jP10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxbXFxuXFxyXSkqKSk/L3VcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRzXVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHVyaSwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9ICovXG4gIGNvbnN0IHBhcnNlZCA9IHtcbiAgICBzY2hlbWU6IHVuZGVmaW5lZCxcbiAgICB1c2VyaW5mbzogdW5kZWZpbmVkLFxuICAgIGhvc3Q6ICcnLFxuICAgIHBvcnQ6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiAnJyxcbiAgICBxdWVyeTogdW5kZWZpbmVkLFxuICAgIGZyYWdtZW50OiB1bmRlZmluZWRcbiAgfVxuXG4gIGxldCBpc0lQID0gZmFsc2VcbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSAnc3VmZml4Jykge1xuICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgdXJpID0gb3B0aW9ucy5zY2hlbWUgKyAnOicgKyB1cmlcbiAgICB9IGVsc2Uge1xuICAgICAgdXJpID0gJy8vJyArIHVyaVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSB1cmkubWF0Y2goVVJJX1BBUlNFKVxuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgLy8gc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICBwYXJzZWQuc2NoZW1lID0gbWF0Y2hlc1sxXVxuICAgIHBhcnNlZC51c2VyaW5mbyA9IG1hdGNoZXNbM11cbiAgICBwYXJzZWQuaG9zdCA9IG1hdGNoZXNbNF1cbiAgICBwYXJzZWQucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKVxuICAgIHBhcnNlZC5wYXRoID0gbWF0Y2hlc1s2XSB8fCAnJ1xuICAgIHBhcnNlZC5xdWVyeSA9IG1hdGNoZXNbN11cbiAgICBwYXJzZWQuZnJhZ21lbnQgPSBtYXRjaGVzWzhdXG5cbiAgICAvLyBmaXggcG9ydCBudW1iZXJcbiAgICBpZiAoaXNOYU4ocGFyc2VkLnBvcnQpKSB7XG4gICAgICBwYXJzZWQucG9ydCA9IG1hdGNoZXNbNV1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5ob3N0KSB7XG4gICAgICBjb25zdCBpcHY0cmVzdWx0ID0gaXNJUHY0KHBhcnNlZC5ob3N0KVxuICAgICAgaWYgKGlwdjRyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlwdjZyZXN1bHQgPSBub3JtYWxpemVJUHY2KHBhcnNlZC5ob3N0KVxuICAgICAgICBwYXJzZWQuaG9zdCA9IGlwdjZyZXN1bHQuaG9zdC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlzSVAgPSBpcHY2cmVzdWx0LmlzSVBWNlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNJUCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQuaG9zdCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5wb3J0ID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnF1ZXJ5ID09PSB1bmRlZmluZWQgJiYgIXBhcnNlZC5wYXRoKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3NhbWUtZG9jdW1lbnQnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAncmVsYXRpdmUnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdhYnNvbHV0ZSdcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICd1cmknXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBwYXJzZWQucmVmZXJlbmNlKSB7XG4gICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBpcyBub3QgYSAnICsgb3B0aW9ucy5yZWZlcmVuY2UgKyAnIHJlZmVyZW5jZS4nXG4gICAgfVxuXG4gICAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKG9wdGlvbnMuc2NoZW1lIHx8IHBhcnNlZC5zY2hlbWUpXG5cbiAgICAvLyBjaGVjayBpZiBzY2hlbWUgY2FuJ3QgaGFuZGxlIElSSXNcbiAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgLy8gaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgaWYgKHBhcnNlZC5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkgJiYgaXNJUCA9PT0gZmFsc2UgJiYgbm9uU2ltcGxlRG9tYWluKHBhcnNlZC5ob3N0KSkge1xuICAgICAgICAvLyBjb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZC5ob3N0ID0gVVJMLmRvbWFpblRvQVNDSUkocGFyc2VkLmhvc3QudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSTogXCIgKyBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgSVJJIC0+IFVSSVxuICAgIH1cblxuICAgIGlmICghc2NoZW1lSGFuZGxlciB8fCAoc2NoZW1lSGFuZGxlciAmJiAhc2NoZW1lSGFuZGxlci5za2lwTm9ybWFsaXplKSkge1xuICAgICAgaWYgKHVyaS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgIGlmIChwYXJzZWQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJzZWQuc2NoZW1lID0gdW5lc2NhcGUocGFyc2VkLnNjaGVtZSlcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcnNlZC5ob3N0ID0gdW5lc2NhcGUocGFyc2VkLmhvc3QpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IGVzY2FwZSh1bmVzY2FwZShwYXJzZWQucGF0aCkpXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLmZyYWdtZW50KSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudCxcbiAgZXF1YWwsXG4gIHNlcmlhbGl6ZSxcbiAgcGFyc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmYXN0VXJpXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZmFzdFVyaSA9IGZhc3RVcmlcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/fast-uri/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/fast-uri/lib/schemes.js":
/*!**********************************************!*\
  !*** ./node_modules/fast-uri/lib/schemes.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { isUUID } = __webpack_require__(/*! ./utils */ \"(action-browser)/./node_modules/fast-uri/lib/utils.js\")\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nconst supportedSchemeNames = /** @type {const} */ (['http', 'https', 'ws',\n  'wss', 'urn', 'urn:uuid'])\n\n/** @typedef {supportedSchemeNames[number]} SchemeName */\n\n/**\n * @param {string} name\n * @returns {name is SchemeName}\n */\nfunction isValidSchemeName (name) {\n  return supportedSchemeNames.indexOf(/** @type {*} */ (name)) !== -1\n}\n\n/**\n * @callback SchemeFn\n * @param {import('../types/index').URIComponent} component\n * @param {import('../types/index').Options} options\n * @returns {import('../types/index').URIComponent}\n */\n\n/**\n * @typedef {Object} SchemeHandler\n * @property {SchemeName} scheme - The scheme name.\n * @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.\n * @property {SchemeFn} parse - Function to parse the URI component for this scheme.\n * @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.\n * @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.\n * @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.\n * @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.\n */\n\n/**\n * @param {import('../types/index').URIComponent} wsComponent\n * @returns {boolean}\n */\nfunction wsIsSecure (wsComponent) {\n  if (wsComponent.secure === true) {\n    return true\n  } else if (wsComponent.secure === false) {\n    return false\n  } else if (wsComponent.scheme) {\n    return (\n      wsComponent.scheme.length === 3 &&\n      (wsComponent.scheme[0] === 'w' || wsComponent.scheme[0] === 'W') &&\n      (wsComponent.scheme[1] === 's' || wsComponent.scheme[1] === 'S') &&\n      (wsComponent.scheme[2] === 's' || wsComponent.scheme[2] === 'S')\n    )\n  } else {\n    return false\n  }\n}\n\n/** @type {SchemeFn} */\nfunction httpParse (component) {\n  if (!component.host) {\n    component.error = component.error || 'HTTP URIs must have a host.'\n  }\n\n  return component\n}\n\n/** @type {SchemeFn} */\nfunction httpSerialize (component) {\n  const secure = String(component.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (component.port === (secure ? 443 : 80) || component.port === '') {\n    component.port = undefined\n  }\n\n  // normalize the empty path\n  if (!component.path) {\n    component.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return component\n}\n\n/** @type {SchemeFn} */\nfunction wsParse (wsComponent) {\n// indicate if the secure flag is set\n  wsComponent.secure = wsIsSecure(wsComponent)\n\n  // construct resouce name\n  wsComponent.resourceName = (wsComponent.path || '/') + (wsComponent.query ? '?' + wsComponent.query : '')\n  wsComponent.path = undefined\n  wsComponent.query = undefined\n\n  return wsComponent\n}\n\n/** @type {SchemeFn} */\nfunction wsSerialize (wsComponent) {\n// normalize the default port\n  if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === '') {\n    wsComponent.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponent.secure === 'boolean') {\n    wsComponent.scheme = (wsComponent.secure ? 'wss' : 'ws')\n    wsComponent.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponent.resourceName) {\n    const [path, query] = wsComponent.resourceName.split('?')\n    wsComponent.path = (path && path !== '/' ? path : undefined)\n    wsComponent.query = query\n    wsComponent.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponent.fragment = undefined\n\n  return wsComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnParse (urnComponent, options) {\n  if (!urnComponent.path) {\n    urnComponent.error = 'URN can not be parsed'\n    return urnComponent\n  }\n  const matches = urnComponent.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponent.scheme || 'urn'\n    urnComponent.nid = matches[1].toLowerCase()\n    urnComponent.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`\n    const schemeHandler = getSchemeHandler(urnScheme)\n    urnComponent.path = undefined\n\n    if (schemeHandler) {\n      urnComponent = schemeHandler.parse(urnComponent, options)\n    }\n  } else {\n    urnComponent.error = urnComponent.error || 'URN can not be parsed.'\n  }\n\n  return urnComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnSerialize (urnComponent, options) {\n  if (urnComponent.nid === undefined) {\n    throw new Error('URN without nid cannot be serialized')\n  }\n  const scheme = options.scheme || urnComponent.scheme || 'urn'\n  const nid = urnComponent.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = getSchemeHandler(urnScheme)\n\n  if (schemeHandler) {\n    urnComponent = schemeHandler.serialize(urnComponent, options)\n  }\n\n  const uriComponent = urnComponent\n  const nss = urnComponent.nss\n  uriComponent.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnuuidParse (urnComponent, options) {\n  const uuidComponent = urnComponent\n  uuidComponent.uuid = uuidComponent.nss\n  uuidComponent.nss = undefined\n\n  if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {\n    uuidComponent.error = uuidComponent.error || 'UUID is not valid.'\n  }\n\n  return uuidComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnuuidSerialize (uuidComponent) {\n  const urnComponent = uuidComponent\n  // normalize UUID\n  urnComponent.nss = (uuidComponent.uuid || '').toLowerCase()\n  return urnComponent\n}\n\nconst http = /** @type {SchemeHandler} */ ({\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n})\n\nconst https = /** @type {SchemeHandler} */ ({\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n})\n\nconst ws = /** @type {SchemeHandler} */ ({\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n})\n\nconst wss = /** @type {SchemeHandler} */ ({\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n})\n\nconst urn = /** @type {SchemeHandler} */ ({\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n})\n\nconst urnuuid = /** @type {SchemeHandler} */ ({\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n})\n\nconst SCHEMES = /** @type {Record<SchemeName, SchemeHandler>} */ ({\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n})\n\nObject.setPrototypeOf(SCHEMES, null)\n\n/**\n * @param {string|undefined} scheme\n * @returns {SchemeHandler|undefined}\n */\nfunction getSchemeHandler (scheme) {\n  return (\n    scheme && (\n      SCHEMES[/** @type {SchemeName} */ (scheme)] ||\n      SCHEMES[/** @type {SchemeName} */(scheme.toLowerCase())])\n  ) ||\n    undefined\n}\n\nmodule.exports = {\n  wsIsSecure,\n  SCHEMES,\n  isValidSchemeName,\n  getSchemeHandler,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NoZW1lcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHNFQUFTO0FBQ3BDLG1DQUFtQyxLQUFLLHNCQUFzQixhQUFhLEVBQUU7O0FBRTdFLHdDQUF3QyxPQUFPO0FBQy9DOztBQUVBLGNBQWMsOEJBQThCOztBQUU1QztBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGlEQUFpRCxHQUFHO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHVDQUF1QztBQUNsRCxXQUFXLGtDQUFrQztBQUM3QyxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxZQUFZO0FBQzFCLGNBQWMsU0FBUztBQUN2QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCOztBQUVBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLEdBQUcsZ0NBQWdDO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU8sR0FBRyxtQkFBbUI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CLEdBQUcsSUFBSTs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDJCQUEyQixtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZO0FBQ3JDLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL3VzZXIvc3R1ZGlvL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvc2NoZW1lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpc1VVSUQgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgVVJOX1JFRyA9IC8oW1xcZGEtel1bXFxkXFwtYS16XXswLDMxfSk6KCg/OltcXHchJCcoKSorLFxcLS46Oz1AXXwlW1xcZGEtZl17Mn0pKykvaXVcblxuY29uc3Qgc3VwcG9ydGVkU2NoZW1lTmFtZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydodHRwJywgJ2h0dHBzJywgJ3dzJyxcbiAgJ3dzcycsICd1cm4nLCAndXJuOnV1aWQnXSlcblxuLyoqIEB0eXBlZGVmIHtzdXBwb3J0ZWRTY2hlbWVOYW1lc1tudW1iZXJdfSBTY2hlbWVOYW1lICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuYW1lIGlzIFNjaGVtZU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTY2hlbWVOYW1lIChuYW1lKSB7XG4gIHJldHVybiBzdXBwb3J0ZWRTY2hlbWVOYW1lcy5pbmRleE9mKC8qKiBAdHlwZSB7Kn0gKi8gKG5hbWUpKSAhPT0gLTFcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2NoZW1lRm5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNjaGVtZUhhbmRsZXJcbiAqIEBwcm9wZXJ0eSB7U2NoZW1lTmFtZX0gc2NoZW1lIC0gVGhlIHNjaGVtZSBuYW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZG9tYWluSG9zdF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSBzdXBwb3J0cyBkb21haW4gaG9zdHMuXG4gKiBAcHJvcGVydHkge1NjaGVtZUZufSBwYXJzZSAtIEZ1bmN0aW9uIHRvIHBhcnNlIHRoZSBVUkkgY29tcG9uZW50IGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7U2NoZW1lRm59IHNlcmlhbGl6ZSAtIEZ1bmN0aW9uIHRvIHNlcmlhbGl6ZSB0aGUgVVJJIGNvbXBvbmVudCBmb3IgdGhpcyBzY2hlbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtza2lwTm9ybWFsaXplXSAtIEluZGljYXRlcyBpZiBub3JtYWxpemF0aW9uIHNob3VsZCBiZSBza2lwcGVkIGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Fic29sdXRlUGF0aF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSB1c2VzIGFic29sdXRlIHBhdGhzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdW5pY29kZVN1cHBvcnRdIC0gSW5kaWNhdGVzIGlmIHRoZSBzY2hlbWUgc3VwcG9ydHMgVW5pY29kZS5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gd3NDb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB3c0lzU2VjdXJlICh3c0NvbXBvbmVudCkge1xuICBpZiAod3NDb21wb25lbnQuc2VjdXJlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmICh3c0NvbXBvbmVudC5zZWN1cmUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAod3NDb21wb25lbnQuc2NoZW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHdzQ29tcG9uZW50LnNjaGVtZS5sZW5ndGggPT09IDMgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMF0gPT09ICd3JyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMF0gPT09ICdXJykgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMV0gPT09ICdzJyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMV0gPT09ICdTJykgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMl0gPT09ICdzJyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMl0gPT09ICdTJylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIGh0dHBQYXJzZSAoY29tcG9uZW50KSB7XG4gIGlmICghY29tcG9uZW50Lmhvc3QpIHtcbiAgICBjb21wb25lbnQuZXJyb3IgPSBjb21wb25lbnQuZXJyb3IgfHwgJ0hUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LidcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIGh0dHBTZXJpYWxpemUgKGNvbXBvbmVudCkge1xuICBjb25zdCBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50LnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ2h0dHBzJ1xuXG4gIC8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmIChjb21wb25lbnQucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnQucG9ydCA9PT0gJycpIHtcbiAgICBjb21wb25lbnQucG9ydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gIGlmICghY29tcG9uZW50LnBhdGgpIHtcbiAgICBjb21wb25lbnQucGF0aCA9ICcvJ1xuICB9XG5cbiAgLy8gTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuICAvLyBhcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgLy8gYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG4gIHJldHVybiBjb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHdzUGFyc2UgKHdzQ29tcG9uZW50KSB7XG4vLyBpbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gIHdzQ29tcG9uZW50LnNlY3VyZSA9IHdzSXNTZWN1cmUod3NDb21wb25lbnQpXG5cbiAgLy8gY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnQucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50LnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnQucXVlcnkgOiAnJylcbiAgd3NDb21wb25lbnQucGF0aCA9IHVuZGVmaW5lZFxuICB3c0NvbXBvbmVudC5xdWVyeSA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gd3NTZXJpYWxpemUgKHdzQ29tcG9uZW50KSB7XG4vLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAod3NDb21wb25lbnQucG9ydCA9PT0gKHdzSXNTZWN1cmUod3NDb21wb25lbnQpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50LnBvcnQgPT09ICcnKSB7XG4gICAgd3NDb21wb25lbnQucG9ydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gIGlmICh0eXBlb2Ygd3NDb21wb25lbnQuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICB3c0NvbXBvbmVudC5zY2hlbWUgPSAod3NDb21wb25lbnQuc2VjdXJlID8gJ3dzcycgOiAnd3MnKVxuICAgIHdzQ29tcG9uZW50LnNlY3VyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgaWYgKHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSkge1xuICAgIGNvbnN0IFtwYXRoLCBxdWVyeV0gPSB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKVxuICAgIHdzQ29tcG9uZW50LnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKVxuICAgIHdzQ29tcG9uZW50LnF1ZXJ5ID0gcXVlcnlcbiAgICB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIGZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgd3NDb21wb25lbnQuZnJhZ21lbnQgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVyblBhcnNlICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKCF1cm5Db21wb25lbnQucGF0aCkge1xuICAgIHVybkNvbXBvbmVudC5lcnJvciA9ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQnXG4gICAgcmV0dXJuIHVybkNvbXBvbmVudFxuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSB1cm5Db21wb25lbnQucGF0aC5tYXRjaChVUk5fUkVHKVxuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudC5zY2hlbWUgfHwgJ3VybidcbiAgICB1cm5Db21wb25lbnQubmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG4gICAgdXJuQ29tcG9uZW50Lm5zcyA9IG1hdGNoZXNbMl1cbiAgICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgdXJuQ29tcG9uZW50Lm5pZH1gXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIodXJuU2NoZW1lKVxuICAgIHVybkNvbXBvbmVudC5wYXRoID0gdW5kZWZpbmVkXG5cbiAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgdXJuQ29tcG9uZW50ID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybkNvbXBvbmVudC5lcnJvciA9IHVybkNvbXBvbmVudC5lcnJvciB8fCAnVVJOIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuXG4gIHJldHVybiB1cm5Db21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVyblNlcmlhbGl6ZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGlmICh1cm5Db21wb25lbnQubmlkID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTiB3aXRob3V0IG5pZCBjYW5ub3QgYmUgc2VyaWFsaXplZCcpXG4gIH1cbiAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50LnNjaGVtZSB8fCAndXJuJ1xuICBjb25zdCBuaWQgPSB1cm5Db21wb25lbnQubmlkLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKHVyblNjaGVtZSlcblxuICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgIHVybkNvbXBvbmVudCA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudCwgb3B0aW9ucylcbiAgfVxuXG4gIGNvbnN0IHVyaUNvbXBvbmVudCA9IHVybkNvbXBvbmVudFxuICBjb25zdCBuc3MgPSB1cm5Db21wb25lbnQubnNzXG4gIHVyaUNvbXBvbmVudC5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gXG5cbiAgb3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gdXJpQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm51dWlkUGFyc2UgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBjb25zdCB1dWlkQ29tcG9uZW50ID0gdXJuQ29tcG9uZW50XG4gIHV1aWRDb21wb25lbnQudXVpZCA9IHV1aWRDb21wb25lbnQubnNzXG4gIHV1aWRDb21wb25lbnQubnNzID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudC51dWlkIHx8ICFpc1VVSUQodXVpZENvbXBvbmVudC51dWlkKSkpIHtcbiAgICB1dWlkQ29tcG9uZW50LmVycm9yID0gdXVpZENvbXBvbmVudC5lcnJvciB8fCAnVVVJRCBpcyBub3QgdmFsaWQuJ1xuICB9XG5cbiAgcmV0dXJuIHV1aWRDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVybnV1aWRTZXJpYWxpemUgKHV1aWRDb21wb25lbnQpIHtcbiAgY29uc3QgdXJuQ29tcG9uZW50ID0gdXVpZENvbXBvbmVudFxuICAvLyBub3JtYWxpemUgVVVJRFxuICB1cm5Db21wb25lbnQubnNzID0gKHV1aWRDb21wb25lbnQudXVpZCB8fCAnJykudG9Mb3dlckNhc2UoKVxuICByZXR1cm4gdXJuQ29tcG9uZW50XG59XG5cbmNvbnN0IGh0dHAgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ2h0dHAnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn0pXG5cbmNvbnN0IGh0dHBzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICdodHRwcycsXG4gIGRvbWFpbkhvc3Q6IGh0dHAuZG9tYWluSG9zdCxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59KVxuXG5jb25zdCB3cyA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnd3MnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogd3NQYXJzZSxcbiAgc2VyaWFsaXplOiB3c1NlcmlhbGl6ZVxufSlcblxuY29uc3Qgd3NzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd3c3MnLFxuICBkb21haW5Ib3N0OiB3cy5kb21haW5Ib3N0LFxuICBwYXJzZTogd3MucGFyc2UsXG4gIHNlcmlhbGl6ZTogd3Muc2VyaWFsaXplXG59KVxuXG5jb25zdCB1cm4gPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3VybicsXG4gIHBhcnNlOiB1cm5QYXJzZSxcbiAgc2VyaWFsaXplOiB1cm5TZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn0pXG5cbmNvbnN0IHVybnV1aWQgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3Vybjp1dWlkJyxcbiAgcGFyc2U6IHVybnV1aWRQYXJzZSxcbiAgc2VyaWFsaXplOiB1cm51dWlkU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59KVxuXG5jb25zdCBTQ0hFTUVTID0gLyoqIEB0eXBlIHtSZWNvcmQ8U2NoZW1lTmFtZSwgU2NoZW1lSGFuZGxlcj59ICovICh7XG4gIGh0dHAsXG4gIGh0dHBzLFxuICB3cyxcbiAgd3NzLFxuICB1cm4sXG4gICd1cm46dXVpZCc6IHVybnV1aWRcbn0pXG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihTQ0hFTUVTLCBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gc2NoZW1lXG4gKiBAcmV0dXJucyB7U2NoZW1lSGFuZGxlcnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtZUhhbmRsZXIgKHNjaGVtZSkge1xuICByZXR1cm4gKFxuICAgIHNjaGVtZSAmJiAoXG4gICAgICBTQ0hFTUVTWy8qKiBAdHlwZSB7U2NoZW1lTmFtZX0gKi8gKHNjaGVtZSldIHx8XG4gICAgICBTQ0hFTUVTWy8qKiBAdHlwZSB7U2NoZW1lTmFtZX0gKi8oc2NoZW1lLnRvTG93ZXJDYXNlKCkpXSlcbiAgKSB8fFxuICAgIHVuZGVmaW5lZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd3NJc1NlY3VyZSxcbiAgU0NIRU1FUyxcbiAgaXNWYWxpZFNjaGVtZU5hbWUsXG4gIGdldFNjaGVtZUhhbmRsZXIsXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/fast-uri/lib/schemes.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/fast-uri/lib/utils.js":
/*!********************************************!*\
  !*** ./node_modules/fast-uri/lib/utils.js ***!
  \********************************************/
/***/ ((module) => {

eval("\n\n/** @type {(value: string) => boolean} */\nconst isUUID = RegExp.prototype.test.bind(/^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu)\n\n/** @type {(value: string) => boolean} */\nconst isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u)\n\n/**\n * @param {Array<string>} input\n * @returns {string}\n */\nfunction stringArrayToHexStripped (input) {\n  let acc = ''\n  let code = 0\n  let i = 0\n\n  for (i = 0; i < input.length; i++) {\n    code = input[i].charCodeAt(0)\n    if (code === 48) {\n      continue\n    }\n    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {\n      return ''\n    }\n    acc += input[i]\n    break\n  }\n\n  for (i += 1; i < input.length; i++) {\n    code = input[i].charCodeAt(0)\n    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {\n      return ''\n    }\n    acc += input[i]\n  }\n  return acc\n}\n\n/**\n * @typedef {Object} GetIPV6Result\n * @property {boolean} error - Indicates if there was an error parsing the IPv6 address.\n * @property {string} address - The parsed IPv6 address.\n * @property {string} [zone] - The zone identifier, if present.\n */\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nconst nonSimpleDomain = RegExp.prototype.test.bind(/[^!\"$&'()*+,\\-.;=_`a-z{}~]/u)\n\n/**\n * @param {Array<string>} buffer\n * @returns {boolean}\n */\nfunction consumeIsZone (buffer) {\n  buffer.length = 0\n  return true\n}\n\n/**\n * @param {Array<string>} buffer\n * @param {Array<string>} address\n * @param {GetIPV6Result} output\n * @returns {boolean}\n */\nfunction consumeHextets (buffer, address, output) {\n  if (buffer.length) {\n    const hex = stringArrayToHexStripped(buffer)\n    if (hex !== '') {\n      address.push(hex)\n    } else {\n      output.error = true\n      return false\n    }\n    buffer.length = 0\n  }\n  return true\n}\n\n/**\n * @param {string} input\n * @returns {GetIPV6Result}\n */\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  /** @type {Array<string>} */\n  const address = []\n  /** @type {Array<string>} */\n  const buffer = []\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  let consume = consumeHextets\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume(buffer, address, output)) { break }\n      if (++tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i > 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      address.push(':')\n      continue\n    } else if (cursor === '%') {\n      if (!consume(buffer, address, output)) { break }\n      // switch to zone detection\n      consume = consumeIsZone\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (consume === consumeIsZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\n/**\n * @typedef {Object} NormalizeIPv6Result\n * @property {string} host - The normalized host.\n * @property {string} [escapedHost] - The escaped host.\n * @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.\n */\n\n/**\n * @param {string} host\n * @returns {NormalizeIPv6Result}\n */\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, isIPV6: true, escapedHost }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\n/**\n * @param {string} str\n * @param {string} token\n * @returns {number}\n */\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\n/**\n * @param {string} path\n * @returns {string}\n *\n * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4\n */\nfunction removeDotSegments (path) {\n  let input = path\n  const output = []\n  let nextSlash = -1\n  let len = 0\n\n  // eslint-disable-next-line no-cond-assign\n  while (len = input.length) {\n    if (len === 1) {\n      if (input === '.') {\n        break\n      } else if (input === '/') {\n        output.push('/')\n        break\n      } else {\n        output.push(input)\n        break\n      }\n    } else if (len === 2) {\n      if (input[0] === '.') {\n        if (input[1] === '.') {\n          break\n        } else if (input[1] === '/') {\n          input = input.slice(2)\n          continue\n        }\n      } else if (input[0] === '/') {\n        if (input[1] === '.' || input[1] === '/') {\n          output.push('/')\n          break\n        }\n      }\n    } else if (len === 3) {\n      if (input === '/..') {\n        if (output.length !== 0) {\n          output.pop()\n        }\n        output.push('/')\n        break\n      }\n    }\n    if (input[0] === '.') {\n      if (input[1] === '.') {\n        if (input[2] === '/') {\n          input = input.slice(3)\n          continue\n        }\n      } else if (input[1] === '/') {\n        input = input.slice(2)\n        continue\n      }\n    } else if (input[0] === '/') {\n      if (input[1] === '.') {\n        if (input[2] === '/') {\n          input = input.slice(2)\n          continue\n        } else if (input[2] === '.') {\n          if (input[3] === '/') {\n            input = input.slice(3)\n            if (output.length !== 0) {\n              output.pop()\n            }\n            continue\n          }\n        }\n      }\n    }\n\n    // Rule 2E: Move normal path segment to output\n    if ((nextSlash = input.indexOf('/', 1)) === -1) {\n      output.push(input)\n      break\n    } else {\n      output.push(input.slice(0, nextSlash))\n      input = input.slice(nextSlash)\n    }\n  }\n\n  return output.join('')\n}\n\n/**\n * @param {import('../types/index').URIComponent} component\n * @param {boolean} esc\n * @returns {import('../types/index').URIComponent}\n */\nfunction normalizeComponentEncoding (component, esc) {\n  const func = esc !== true ? escape : unescape\n  if (component.scheme !== undefined) {\n    component.scheme = func(component.scheme)\n  }\n  if (component.userinfo !== undefined) {\n    component.userinfo = func(component.userinfo)\n  }\n  if (component.host !== undefined) {\n    component.host = func(component.host)\n  }\n  if (component.path !== undefined) {\n    component.path = func(component.path)\n  }\n  if (component.query !== undefined) {\n    component.query = func(component.query)\n  }\n  if (component.fragment !== undefined) {\n    component.fragment = func(component.fragment)\n  }\n  return component\n}\n\n/**\n * @param {import('../types/index').URIComponent} component\n * @returns {string|undefined}\n */\nfunction recomposeAuthority (component) {\n  const uriTokens = []\n\n  if (component.userinfo !== undefined) {\n    uriTokens.push(component.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (component.host !== undefined) {\n    let host = unescape(component.host)\n    if (!isIPv4(host)) {\n      const ipV6res = normalizeIPv6(host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = component.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof component.port === 'number' || typeof component.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(component.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  nonSimpleDomain,\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  isIPv4,\n  isUUID,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosV0FBVyw0QkFBNEI7QUFDdkMsb0RBQW9ELEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxHQUFHOztBQUVuRyxXQUFXLDRCQUE0QjtBQUN2Qyx1RUFBdUUsRUFBRSxnQkFBZ0IsRUFBRSx3QkFBd0IsRUFBRTs7QUFFckg7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxvRUFBb0UsUUFBUTs7QUFFNUU7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsdUNBQXVDO0FBQ2xELGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvdXNlci9zdHVkaW8vbm9kZV9tb2R1bGVzL2Zhc3QtdXJpL2xpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlIHsodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cbmNvbnN0IGlzVVVJRCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdSlcblxuLyoqIEB0eXBlIHsodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cbmNvbnN0IGlzSVB2NCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKSQvdSlcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQgKGlucHV0KSB7XG4gIGxldCBhY2MgPSAnJ1xuICBsZXQgY29kZSA9IDBcbiAgbGV0IGkgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGlucHV0W2ldLmNoYXJDb2RlQXQoMClcbiAgICBpZiAoY29kZSA9PT0gNDgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICghKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IChjb2RlID49IDY1ICYmIGNvZGUgPD0gNzApIHx8IChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKSkpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBhY2MgKz0gaW5wdXRbaV1cbiAgICBicmVha1xuICB9XG5cbiAgZm9yIChpICs9IDE7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvZGUgPSBpbnB1dFtpXS5jaGFyQ29kZUF0KDApXG4gICAgaWYgKCEoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgfHwgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIpKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGFjYyArPSBpbnB1dFtpXVxuICB9XG4gIHJldHVybiBhY2Ncbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHZXRJUFY2UmVzdWx0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVycm9yIC0gSW5kaWNhdGVzIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBJUHY2IGFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBwYXJzZWQgSVB2NiBhZGRyZXNzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b25lXSAtIFRoZSB6b25lIGlkZW50aWZpZXIsIGlmIHByZXNlbnQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBub25TaW1wbGVEb21haW4gPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvW14hXCIkJicoKSorLFxcLS47PV9gYS16e31+XS91KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYnVmZmVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZUlzWm9uZSAoYnVmZmVyKSB7XG4gIGJ1ZmZlci5sZW5ndGggPSAwXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBidWZmZXJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWRkcmVzc1xuICogQHBhcmFtIHtHZXRJUFY2UmVzdWx0fSBvdXRwdXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb25zdW1lSGV4dGV0cyAoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgIGlmIChoZXggIT09ICcnKSB7XG4gICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHJldHVybnMge0dldElQVjZSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBhZGRyZXNzID0gW11cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBidWZmZXIgPSBbXVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGxldCBjb25zdW1lID0gY29uc3VtZUhleHRldHNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3Vyc29yID0gaW5wdXRbaV1cbiAgICBpZiAoY3Vyc29yID09PSAnWycgfHwgY3Vyc29yID09PSAnXScpIHsgY29udGludWUgfVxuICAgIGlmIChjdXJzb3IgPT09ICc6Jykge1xuICAgICAgaWYgKGVuZGlwdjZFbmNvdW50ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlbmRJcHY2ID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCFjb25zdW1lKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSkgeyBicmVhayB9XG4gICAgICBpZiAoKyt0b2tlbkNvdW50ID4gNykge1xuICAgICAgICAvLyBub3QgdmFsaWRcbiAgICAgICAgb3V0cHV0LmVycm9yID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoY3Vyc29yID09PSAnJScpIHtcbiAgICAgIGlmICghY29uc3VtZShidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBjb25zdW1lID0gY29uc3VtZUlzWm9uZVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjdXJzb3IpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChjb25zdW1lID09PSBjb25zdW1lSXNab25lKSB7XG4gICAgICBvdXRwdXQuem9uZSA9IGJ1ZmZlci5qb2luKCcnKVxuICAgIH0gZWxzZSBpZiAoZW5kSXB2Nikge1xuICAgICAgYWRkcmVzcy5wdXNoKGJ1ZmZlci5qb2luKCcnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkcmVzcy5wdXNoKHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZChidWZmZXIpKVxuICAgIH1cbiAgfVxuICBvdXRwdXQuYWRkcmVzcyA9IGFkZHJlc3Muam9pbignJylcbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE5vcm1hbGl6ZUlQdjZSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBob3N0IC0gVGhlIG5vcm1hbGl6ZWQgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXNjYXBlZEhvc3RdIC0gVGhlIGVzY2FwZWQgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNJUFY2IC0gSW5kaWNhdGVzIGlmIHRoZSBob3N0IGlzIGFuIElQdjYgYWRkcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0XG4gKiBAcmV0dXJucyB7Tm9ybWFsaXplSVB2NlJlc3VsdH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICc6JykgPCAyKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfSB9XG4gIGNvbnN0IGlwdjYgPSBnZXRJUFY2KGhvc3QpXG5cbiAgaWYgKCFpcHY2LmVycm9yKSB7XG4gICAgbGV0IG5ld0hvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBsZXQgZXNjYXBlZEhvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBpZiAoaXB2Ni56b25lKSB7XG4gICAgICBuZXdIb3N0ICs9ICclJyArIGlwdjYuem9uZVxuICAgICAgZXNjYXBlZEhvc3QgKz0gJyUyNScgKyBpcHY2LnpvbmVcbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgaXNJUFY2OiB0cnVlLCBlc2NhcGVkSG9zdCB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRUb2tlbiAoc3RyLCB0b2tlbikge1xuICBsZXQgaW5kID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IHRva2VuKSBpbmQrK1xuICB9XG4gIHJldHVybiBpbmRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi40XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzIChwYXRoKSB7XG4gIGxldCBpbnB1dCA9IHBhdGhcbiAgY29uc3Qgb3V0cHV0ID0gW11cbiAgbGV0IG5leHRTbGFzaCA9IC0xXG4gIGxldCBsZW4gPSAwXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gIHdoaWxlIChsZW4gPSBpbnB1dC5sZW5ndGgpIHtcbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcuJykge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gJy8nKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGlucHV0KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICBpZiAoaW5wdXRbMF0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0WzBdID09PSAnLycpIHtcbiAgICAgICAgaWYgKGlucHV0WzFdID09PSAnLicgfHwgaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJy8uLicpIHtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBvdXRwdXQucG9wKClcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHVzaCgnLycpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dFswXSA9PT0gJy4nKSB7XG4gICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMl0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMylcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0WzFdID09PSAnLycpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5wdXRbMF0gPT09ICcvJykge1xuICAgICAgaWYgKGlucHV0WzFdID09PSAnLicpIHtcbiAgICAgICAgaWYgKGlucHV0WzJdID09PSAnLycpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFsyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgaWYgKGlucHV0WzNdID09PSAnLycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMylcbiAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIG91dHB1dC5wb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSdWxlIDJFOiBNb3ZlIG5vcm1hbCBwYXRoIHNlZ21lbnQgdG8gb3V0cHV0XG4gICAgaWYgKChuZXh0U2xhc2ggPSBpbnB1dC5pbmRleE9mKCcvJywgMSkpID09PSAtMSkge1xuICAgICAgb3V0cHV0LnB1c2goaW5wdXQpXG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChpbnB1dC5zbGljZSgwLCBuZXh0U2xhc2gpKVxuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShuZXh0U2xhc2gpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY1xuICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIChjb21wb25lbnQsIGVzYykge1xuICBjb25zdCBmdW5jID0gZXNjICE9PSB0cnVlID8gZXNjYXBlIDogdW5lc2NhcGVcbiAgaWYgKGNvbXBvbmVudC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5zY2hlbWUgPSBmdW5jKGNvbXBvbmVudC5zY2hlbWUpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnVzZXJpbmZvID0gZnVuYyhjb21wb25lbnQudXNlcmluZm8pXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuaG9zdCA9IGZ1bmMoY29tcG9uZW50Lmhvc3QpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQucGF0aCA9IGZ1bmMoY29tcG9uZW50LnBhdGgpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnF1ZXJ5ID0gZnVuYyhjb21wb25lbnQucXVlcnkpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LmZyYWdtZW50ID0gZnVuYyhjb21wb25lbnQuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcmVjb21wb3NlQXV0aG9yaXR5IChjb21wb25lbnQpIHtcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICBpZiAoY29tcG9uZW50LnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnQudXNlcmluZm8pXG4gICAgdXJpVG9rZW5zLnB1c2goJ0AnKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaG9zdCA9IHVuZXNjYXBlKGNvbXBvbmVudC5ob3N0KVxuICAgIGlmICghaXNJUHY0KGhvc3QpKSB7XG4gICAgICBjb25zdCBpcFY2cmVzID0gbm9ybWFsaXplSVB2Nihob3N0KVxuICAgICAgaWYgKGlwVjZyZXMuaXNJUFY2ID09PSB0cnVlKSB7XG4gICAgICAgIGhvc3QgPSBgWyR7aXBWNnJlcy5lc2NhcGVkSG9zdH1dYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9zdCA9IGNvbXBvbmVudC5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudC5wb3J0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29tcG9uZW50LnBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJzonKVxuICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnQucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vblNpbXBsZURvbWFpbixcbiAgcmVjb21wb3NlQXV0aG9yaXR5LFxuICBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyxcbiAgcmVtb3ZlRG90U2VnbWVudHMsXG4gIGlzSVB2NCxcbiAgaXNVVUlELFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/fast-uri/lib/utils.js\n");

/***/ })

};
;